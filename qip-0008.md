# QIP-0008: State Staking (Stating)

```
 Layer: Consensus (hard fork)
 Title: State Staking
 Author: alanorwick <alan+qip@quai.org>  
 Comments-Summary: No comments yet.  
 Comments-URI: [https://github.com/quainetwork/qips/wiki/Comments:QIP-0008](https://github.com/quainetwork/qips/wiki/Comments:QIP-0008)  
 Status: Draft  
 Type: Standards Track  
 Created: 2023-09-15  
 License: BSD-2-Clause
```


## Abstract

QIP-0008 defines the state staking methodology to pay for and reap state.

## Motivation

State staking, rent, and expiry allows Quai Network to purge the active state tree. Over time the size of the state trie may become a limiting factor to TPS due to the IOPS associated with updating it. By reducing the depth of the tree and limiting the amount of nodes through incentives, we can improve TPS and create a more sustainable growth trajectory compared to other chains.

## Specification

### Overview
The majority of blockchain clients use either LevelDB or RocksDB to store data. These are particularly optimized database solutions that can only store key-value pairs of arbitrary data in a very efficient way. The drawbacks are that developers can’t perform advanced queries on the database, and the only allowed operations are add(key, value), get(key), and delete(key). [3] Erigon uses a key-value store and converts the key-value DB into a trie-like hash via an algorith that sorts the values into a stack.

![key value](images/key-value.png)

A Merkle Patricia tree is used in order to be able to verify the inclusion of certain data in O(log n) time. A hash of the state of each account in Ethereum is included in the leaf nodes, and bundles of hashes of leaf nodes are included in higher-level nodes until the root of the tree is reached.[3] Merkle Patricia tries are comprised of extension nodes, leaf nodes, branch nodes, and hash nodes. Each node is decided by the sha3 hash value of its contents and the hash is used as a key. 

![merkle patricia](images/merkle-trie.png)

#### Current Limitations
The problem with Merkle Patricia tries is that the more accounts there are, the deeper the state trie becomes.
- Ethereum 174M accounts → 8 trie depth
- Plain transfers update 2 accounts (EOA) - 15 new nodes in account trie 
- LevelDB stores data in 7 disk layers - amplifies 15 new nodes into 105
- Old path read for root hash calculation - bumps to potentially 210 IO ops
- Mined blocks need to propagate - 210 ops miner side, 210 ops full node side 

HDD 80 IOS → .19 TPS \
SSD (SATA 6) 90,000 IOPS → 214 TPS \
SSD (NVMe over PCIe 3) 360,000 IOPS → 857 TPS \
SSD (NVMe over PCIe 4) 1,000,000 IOPS → 2381 TPS

![merkle patricia update](images/merkle-trie-update.png)

#### Asynchronous vs Synchronous Garbage Collection
Some state rent systems, like [the one proposed in Ethereum by Alexey Akhunov](https://github.com/ledgerwatch/eth_state), use a synchronous garbage collection routine. Accounts pay a certain amount of rent to exist for a period of time. This causes the account balances to gradually reduce. If the account balance is too low to pay the rent, it is marked to be evicted. An operational transaction is then due to deterministically evict the account out of the world state. Determinstic garbage collection presents some challenges:

Accounts constantly need to pay rent. While the number of times dues happen can be optimized (to only pay it when an account is updated), it still causes unnecessary state updates.

Eviction is costly. All accounts that need to be evicted must be done so deterministically. While we can limit the number of evictions per block, this can still cause massive merkle tree updates.

Our preferred approach is to use an asynchronous garbage collection routine that incentives users to reclaim unused state.

## Implementation
There are a some key priorities we'd like for our state staking algorithm:
1. It is based on a market.
2. It is asynchronous.
3. It is deterministic.
4. It is triggered by the account owner.

The stating deposit will be held by the account balance. There are two primary ways of tracking state costs:
1. The trie deposit
2. EOA / Contract data

The trie deposit is based on the amount of trie nodes that roll into the state root. When an EOA or contract has a balance less than the trie deposit, the account will only be able to transfer QUAI. All other forms of interaction will fail on the account.

EOA state root leaf: \
`deposit(node) = log10(trie_nodes) * 1 QUAI`

Contract state root leaf: \
`deposit(node) = log10(trie_nodes) * 1 QUAI`


The EOA / contract data is based on the amount of data stored in the account.

Data Fee: \
`.0001 QUAI = 1 byte`

EOA storage: \
`deposit(storage) = code_size / quai_per_byte`

Contract code: \
`deposit(code) = log10((existing_leaves) * code_size) / quai_per_byte`

Contract storage: \
`deposit(storage) = ((integral of log10(expected_slots)) * slot_size (32 bytes)) / quai_per_byte`


EOAs and contracts must maintain a balance of 1 QUAI for existence in the trie. The cost of having to stake for storage should alleviate growth of the tree since developers are incentivized to manage state.

Examples:
The USDC contract of 4372 bytes in size and deployed when the trie has 8,000,000 leaves. 

```
deposit(code) = (log10(8,000,000) * 4372 bytes) / 1000 = 30.18 QUAI
```

USDC has roughly 1.8M users, using that we can assume a starting point of 1.8M slots.
```
deposit(storage) = (integral of log10(1,800,000)) * 32 bytes) / 1000 = 335,288.33 QUAI
```

Asumming the integral of log10(1,800,000) is roughly 10,477,760.44

The total estimate stating deposit for USDC would be 30.18 + 335,288.33 = 335,318.51 QUAI.

### Modifications to `SSTORE`
When adding storage, a transaction will fail if it is writing more data than the staked rent the contract has paid for.

### Modifications to EOAs
EOAs/contracts that transfer balance resulting in less than 1 QUAI will invoke the `SELFDESTRUCT` opcode on the trie.

### Reclaiming State
After removing state from the contract, the contract owner will be able to send the equivalent amount of QUAI from the account balanace.

## References
* https://docs.solana.com/developing/intro/rent
* https://wiki.polkadot.network/docs/build-protocol-info#existential-deposit
* https://github.com/bnb-chain/BSC-State-Expiry/tree/main
* https://github.com/ethereum/EIPs/issues/35
* https://docs.near.org/concepts/storage/storage-staking

## Copyright

This QIP is licensed under the BSD 2-clause license.